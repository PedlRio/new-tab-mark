{"ast":null,"code":"import { BubbleMenuPlugin } from '@tiptap/extension-bubble-menu';\nimport { Editor as Editor$1, NodeView } from '@tiptap/core';\nexport * from '@tiptap/core';\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu';\nimport Vue from 'vue';\nimport { objectProp, booleanProp, functionProp } from 'vue-ts-types';\nconst BubbleMenu = {\n  name: 'BubbleMenu',\n  props: {\n    pluginKey: {\n      type: [String, Object],\n      default: 'bubbleMenu'\n    },\n    editor: {\n      type: Object,\n      required: true\n    },\n    updateDelay: {\n      type: Number\n    },\n    tippyOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    shouldShow: {\n      type: Function,\n      default: null\n    }\n  },\n  watch: {\n    editor: {\n      immediate: true,\n      handler(editor) {\n        if (!editor) {\n          return;\n        }\n        this.$nextTick(() => {\n          editor.registerPlugin(BubbleMenuPlugin({\n            updateDelay: this.updateDelay,\n            editor,\n            element: this.$el,\n            pluginKey: this.pluginKey,\n            shouldShow: this.shouldShow,\n            tippyOptions: this.tippyOptions\n          }));\n        });\n      }\n    }\n  },\n  render(createElement) {\n    return createElement('div', {\n      style: {\n        visibility: 'hidden'\n      }\n    }, this.$slots.default);\n  },\n  beforeDestroy() {\n    this.editor.unregisterPlugin(this.pluginKey);\n  }\n};\nclass Editor extends Editor$1 {\n  constructor() {\n    super(...arguments);\n    this.contentComponent = null;\n  }\n}\nconst EditorContent = {\n  name: 'EditorContent',\n  props: {\n    editor: {\n      default: null,\n      type: Object\n    }\n  },\n  watch: {\n    editor: {\n      immediate: true,\n      handler(editor) {\n        if (editor && editor.options.element) {\n          this.$nextTick(() => {\n            const element = this.$el;\n            if (!element || !editor.options.element.firstChild) {\n              return;\n            }\n            element.append(...editor.options.element.childNodes);\n            editor.contentComponent = this;\n            editor.setOptions({\n              element\n            });\n            editor.createNodeViews();\n          });\n        }\n      }\n    }\n  },\n  render(createElement) {\n    return createElement('div');\n  },\n  beforeDestroy() {\n    const {\n      editor\n    } = this;\n    if (!editor) {\n      return;\n    }\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    editor.contentComponent = null;\n    if (!editor.options.element.firstChild) {\n      return;\n    }\n    const newElement = document.createElement('div');\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n};\nconst FloatingMenu = {\n  name: 'FloatingMenu',\n  props: {\n    pluginKey: {\n      type: [String, Object],\n      default: 'floatingMenu'\n    },\n    editor: {\n      type: Object,\n      required: true\n    },\n    tippyOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    shouldShow: {\n      type: Function,\n      default: null\n    }\n  },\n  watch: {\n    editor: {\n      immediate: true,\n      handler(editor) {\n        if (!editor) {\n          return;\n        }\n        this.$nextTick(() => {\n          editor.registerPlugin(FloatingMenuPlugin({\n            pluginKey: this.pluginKey,\n            editor,\n            element: this.$el,\n            tippyOptions: this.tippyOptions,\n            shouldShow: this.shouldShow\n          }));\n        });\n      }\n    }\n  },\n  render(createElement) {\n    return createElement('div', {\n      style: {\n        visibility: 'hidden'\n      }\n    }, this.$slots.default);\n  },\n  beforeDestroy() {\n    this.editor.unregisterPlugin(this.pluginKey);\n  }\n};\nconst NodeViewContent = {\n  props: {\n    as: {\n      type: String,\n      default: 'div'\n    }\n  },\n  render(createElement) {\n    return createElement(this.as, {\n      style: {\n        whiteSpace: 'pre-wrap'\n      },\n      attrs: {\n        'data-node-view-content': ''\n      }\n    });\n  }\n};\nconst NodeViewWrapper = {\n  props: {\n    as: {\n      type: String,\n      default: 'div'\n    }\n  },\n  inject: ['onDragStart', 'decorationClasses'],\n  render(createElement) {\n    return createElement(this.as, {\n      class: this.decorationClasses.value,\n      style: {\n        whiteSpace: 'normal'\n      },\n      attrs: {\n        'data-node-view-wrapper': ''\n      },\n      on: {\n        dragstart: this.onDragStart\n      }\n    }, this.$slots.default);\n  }\n};\nclass VueRenderer {\n  constructor(component, props) {\n    const Component = typeof component === 'function' ? component : Vue.extend(component);\n    this.ref = new Component(props).$mount();\n  }\n  get element() {\n    return this.ref.$el;\n  }\n  updateProps(props = {}) {\n    var _a, _b, _c;\n    if (!this.ref.$props) {\n      return;\n    }\n    // prevents `Avoid mutating a prop directly` error message\n    // Fix: `VueNodeViewRenderer` change vue Constructor `config.silent` not working\n    const currentVueConstructor = (_c = (_b = (_a = this.ref.$props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.$options._base) !== null && _c !== void 0 ? _c : Vue; // eslint-disable-line\n    const originalSilent = currentVueConstructor.config.silent;\n    currentVueConstructor.config.silent = true;\n    Object.entries(props).forEach(([key, value]) => {\n      this.ref.$props[key] = value;\n    });\n    currentVueConstructor.config.silent = originalSilent;\n  }\n  destroy() {\n    this.ref.$destroy();\n  }\n}\nconst nodeViewProps = {\n  editor: objectProp().required,\n  node: objectProp().required,\n  decorations: objectProp().required,\n  selected: booleanProp().required,\n  extension: objectProp().required,\n  getPos: functionProp().required,\n  updateAttributes: functionProp().required,\n  deleteNode: functionProp().required\n};\nclass VueNodeView extends NodeView {\n  mount() {\n    var _a, _b;\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      selected: false,\n      extension: this.extension,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode()\n    };\n    const onDragStart = this.onDragStart.bind(this);\n    this.decorationClasses = Vue.observable({\n      value: this.getDecorationClasses()\n    });\n    // @ts-ignore\n    const vue = (_b = (_a = this.editor.contentComponent) === null || _a === void 0 ? void 0 : _a.$options._base) !== null && _b !== void 0 ? _b : Vue; // eslint-disable-line\n    const Component = vue.extend(this.component).extend({\n      props: Object.keys(props),\n      provide: () => {\n        return {\n          onDragStart,\n          decorationClasses: this.decorationClasses\n        };\n      }\n    });\n    this.renderer = new VueRenderer(Component, {\n      parent: this.editor.contentComponent,\n      propsData: props\n    });\n  }\n  get dom() {\n    if (!this.renderer.element.hasAttribute('data-node-view-wrapper')) {\n      throw Error('Please use the NodeViewWrapper component for your node view.');\n    }\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    const contentElement = this.dom.querySelector('[data-node-view-content]');\n    return contentElement || this.dom;\n  }\n  update(node, decorations) {\n    const updateProps = props => {\n      this.decorationClasses.value = this.getDecorationClasses();\n      this.renderer.updateProps(props);\n    };\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      this.node = node;\n      this.decorations = decorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        updateProps: () => updateProps({\n          node,\n          decorations\n        })\n      });\n    }\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (node === this.node && this.decorations === decorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    updateProps({\n      node,\n      decorations\n    });\n    return true;\n  }\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add('ProseMirror-selectednode');\n  }\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove('ProseMirror-selectednode');\n  }\n  getDecorationClasses() {\n    return this.decorations\n    // @ts-ignore\n    .map(item => item.type.attrs.class).flat().join(' ');\n  }\n  destroy() {\n    this.renderer.destroy();\n  }\n}\nfunction VueNodeViewRenderer(component, options) {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new VueNodeView(component, props, options);\n  };\n}\nexport { BubbleMenu, Editor, EditorContent, FloatingMenu, NodeViewContent, NodeViewWrapper, VueNodeViewRenderer, VueRenderer, nodeViewProps };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}