{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { BubbleMenuPlugin } from '@tiptap/extension-bubble-menu';\nimport { defineComponent, ref, onMounted, onBeforeUnmount, h, reactive, markRaw, customRef, getCurrentInstance, watchEffect, nextTick, unref, Teleport, shallowRef, provide } from 'vue';\nimport { Editor as Editor$1, NodeView } from '@tiptap/core';\nexport * from '@tiptap/core';\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu';\nconst BubbleMenu = defineComponent({\n  name: 'BubbleMenu',\n  props: {\n    pluginKey: {\n      type: [String, Object],\n      default: 'bubbleMenu'\n    },\n    editor: {\n      type: Object,\n      required: true\n    },\n    updateDelay: {\n      type: Number,\n      default: undefined\n    },\n    tippyOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    shouldShow: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props, {\n    slots\n  }) {\n    const root = ref(null);\n    onMounted(() => {\n      const {\n        updateDelay,\n        editor,\n        pluginKey,\n        shouldShow,\n        tippyOptions\n      } = props;\n      editor.registerPlugin(BubbleMenuPlugin({\n        updateDelay,\n        editor,\n        element: root.value,\n        pluginKey,\n        shouldShow,\n        tippyOptions\n      }));\n    });\n    onBeforeUnmount(() => {\n      const {\n        pluginKey,\n        editor\n      } = props;\n      editor.unregisterPlugin(pluginKey);\n    });\n    return () => {\n      var _a;\n      return h('div', {\n        ref: root\n      }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));\n    };\n  }\n});\nfunction useDebouncedRef(value) {\n  return customRef((track, trigger) => {\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        // update state\n        value = newValue;\n        // update view as soon as possible\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            trigger();\n          });\n        });\n      }\n    };\n  });\n}\nclass Editor extends Editor$1 {\n  constructor(options = {}) {\n    super(options);\n    this.vueRenderers = reactive(new Map());\n    this.contentComponent = null;\n    this.reactiveState = useDebouncedRef(this.view.state);\n    this.reactiveExtensionStorage = useDebouncedRef(this.extensionStorage);\n    this.on('transaction', () => {\n      this.reactiveState.value = this.view.state;\n      this.reactiveExtensionStorage.value = this.extensionStorage;\n    });\n    return markRaw(this); // eslint-disable-line\n  }\n\n  get state() {\n    return this.reactiveState ? this.reactiveState.value : this.view.state;\n  }\n  get storage() {\n    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;\n  }\n  /**\r\n   * Register a ProseMirror plugin.\r\n   */\n  registerPlugin(plugin, handlePlugins) {\n    super.registerPlugin(plugin, handlePlugins);\n    this.reactiveState.value = this.view.state;\n  }\n  /**\r\n   * Unregister a ProseMirror plugin.\r\n   */\n  unregisterPlugin(nameOrPluginKey) {\n    super.unregisterPlugin(nameOrPluginKey);\n    this.reactiveState.value = this.view.state;\n  }\n}\nconst EditorContent = defineComponent({\n  name: 'EditorContent',\n  props: {\n    editor: {\n      default: null,\n      type: Object\n    }\n  },\n  setup(props) {\n    const rootEl = ref();\n    const instance = getCurrentInstance();\n    watchEffect(() => {\n      const editor = props.editor;\n      if (editor && editor.options.element && rootEl.value) {\n        nextTick(() => {\n          if (!rootEl.value || !editor.options.element.firstChild) {\n            return;\n          }\n          const element = unref(rootEl.value);\n          rootEl.value.append(...editor.options.element.childNodes);\n          // @ts-ignore\n          editor.contentComponent = instance.ctx._;\n          editor.setOptions({\n            element\n          });\n          editor.createNodeViews();\n        });\n      }\n    });\n    onBeforeUnmount(() => {\n      const editor = props.editor;\n      if (!editor) {\n        return;\n      }\n      // destroy nodeviews before vue removes dom element\n      if (!editor.isDestroyed) {\n        editor.view.setProps({\n          nodeViews: {}\n        });\n      }\n      editor.contentComponent = null;\n      if (!editor.options.element.firstChild) {\n        return;\n      }\n      const newElement = document.createElement('div');\n      newElement.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element: newElement\n      });\n    });\n    return {\n      rootEl\n    };\n  },\n  render() {\n    const vueRenderers = [];\n    if (this.editor) {\n      this.editor.vueRenderers.forEach(vueRenderer => {\n        const node = h(Teleport, {\n          to: vueRenderer.teleportElement,\n          key: vueRenderer.id\n        }, h(vueRenderer.component, {\n          ref: vueRenderer.id,\n          ...vueRenderer.props\n        }));\n        vueRenderers.push(node);\n      });\n    }\n    return h('div', {\n      ref: el => {\n        this.rootEl = el;\n      }\n    }, ...vueRenderers);\n  }\n});\nconst FloatingMenu = defineComponent({\n  name: 'FloatingMenu',\n  props: {\n    pluginKey: {\n      // TODO: TypeScript breaks :(\n      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],\n      type: null,\n      default: 'floatingMenu'\n    },\n    editor: {\n      type: Object,\n      required: true\n    },\n    tippyOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    shouldShow: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props, {\n    slots\n  }) {\n    const root = ref(null);\n    onMounted(() => {\n      const {\n        pluginKey,\n        editor,\n        tippyOptions,\n        shouldShow\n      } = props;\n      editor.registerPlugin(FloatingMenuPlugin({\n        pluginKey,\n        editor,\n        element: root.value,\n        tippyOptions,\n        shouldShow\n      }));\n    });\n    onBeforeUnmount(() => {\n      const {\n        pluginKey,\n        editor\n      } = props;\n      editor.unregisterPlugin(pluginKey);\n    });\n    return () => {\n      var _a;\n      return h('div', {\n        ref: root\n      }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));\n    };\n  }\n});\nconst NodeViewContent = defineComponent({\n  name: 'NodeViewContent',\n  props: {\n    as: {\n      type: String,\n      default: 'div'\n    }\n  },\n  render() {\n    return h(this.as, {\n      style: {\n        whiteSpace: 'pre-wrap'\n      },\n      'data-node-view-content': ''\n    });\n  }\n});\nconst NodeViewWrapper = defineComponent({\n  name: 'NodeViewWrapper',\n  props: {\n    as: {\n      type: String,\n      default: 'div'\n    }\n  },\n  inject: ['onDragStart', 'decorationClasses'],\n  render() {\n    var _a, _b;\n    return h(this.as, {\n      // @ts-ignore\n      class: this.decorationClasses,\n      style: {\n        whiteSpace: 'normal'\n      },\n      'data-node-view-wrapper': '',\n      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)\n      onDragstart: this.onDragStart\n    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));\n  }\n});\nconst useEditor = (options = {}) => {\n  const editor = shallowRef();\n  onMounted(() => {\n    editor.value = new Editor(options);\n  });\n  onBeforeUnmount(() => {\n    var _a;\n    (_a = editor.value) === null || _a === void 0 ? void 0 : _a.destroy();\n  });\n  return editor;\n};\nclass VueRenderer {\n  constructor(component, {\n    props = {},\n    editor\n  }) {\n    this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n    this.editor = editor;\n    this.component = markRaw(component);\n    this.teleportElement = document.createElement('div');\n    this.element = this.teleportElement;\n    this.props = reactive(props);\n    this.editor.vueRenderers.set(this.id, this);\n    if (this.editor.contentComponent) {\n      this.editor.contentComponent.update();\n      if (this.teleportElement.children.length !== 1) {\n        throw Error('VueRenderer doesn’t support multiple child elements.');\n      }\n      this.element = this.teleportElement.firstElementChild;\n    }\n  }\n  get ref() {\n    var _a;\n    return (_a = this.editor.contentComponent) === null || _a === void 0 ? void 0 : _a.refs[this.id];\n  }\n  updateProps(props = {}) {\n    Object.entries(props).forEach(([key, value]) => {\n      this.props[key] = value;\n    });\n  }\n  destroy() {\n    this.editor.vueRenderers.delete(this.id);\n  }\n}\nconst nodeViewProps = {\n  editor: {\n    type: Object,\n    required: true\n  },\n  node: {\n    type: Object,\n    required: true\n  },\n  decorations: {\n    type: Object,\n    required: true\n  },\n  selected: {\n    type: Boolean,\n    required: true\n  },\n  extension: {\n    type: Object,\n    required: true\n  },\n  getPos: {\n    type: Function,\n    required: true\n  },\n  updateAttributes: {\n    type: Function,\n    required: true\n  },\n  deleteNode: {\n    type: Function,\n    required: true\n  }\n};\nclass VueNodeView extends NodeView {\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      selected: false,\n      extension: this.extension,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode()\n    };\n    const onDragStart = this.onDragStart.bind(this);\n    this.decorationClasses = ref(this.getDecorationClasses());\n    const extendedComponent = defineComponent({\n      extends: {\n        ...this.component\n      },\n      props: Object.keys(props),\n      template: this.component.template,\n      setup: reactiveProps => {\n        var _a, _b;\n        provide('onDragStart', onDragStart);\n        provide('decorationClasses', this.decorationClasses);\n        return (_b = (_a = this.component).setup) === null || _b === void 0 ? void 0 : _b.call(_a, reactiveProps, {\n          expose: () => undefined\n        });\n      },\n      // add support for scoped styles\n      // @ts-ignore\n      // eslint-disable-next-line\n      __scopeId: this.component.__scopeId,\n      // add support for CSS Modules\n      // @ts-ignore\n      // eslint-disable-next-line\n      __cssModules: this.component.__cssModules,\n      // add support for vue devtools\n      // @ts-ignore\n      // eslint-disable-next-line\n      __name: this.component.__name,\n      // @ts-ignore\n      // eslint-disable-next-line\n      __file: this.component.__file\n    });\n    this.renderer = new VueRenderer(extendedComponent, {\n      editor: this.editor,\n      props\n    });\n  }\n  get dom() {\n    if (!this.renderer.element.hasAttribute('data-node-view-wrapper')) {\n      throw Error('Please use the NodeViewWrapper component for your node view.');\n    }\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    const contentElement = this.dom.querySelector('[data-node-view-content]');\n    return contentElement || this.dom;\n  }\n  update(node, decorations) {\n    const updateProps = props => {\n      this.decorationClasses.value = this.getDecorationClasses();\n      this.renderer.updateProps(props);\n    };\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      this.node = node;\n      this.decorations = decorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        updateProps: () => updateProps({\n          node,\n          decorations\n        })\n      });\n    }\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (node === this.node && this.decorations === decorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    updateProps({\n      node,\n      decorations\n    });\n    return true;\n  }\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add('ProseMirror-selectednode');\n  }\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove('ProseMirror-selectednode');\n  }\n  getDecorationClasses() {\n    return this.decorations\n    // @ts-ignore\n    .map(item => item.type.attrs.class).flat().join(' ');\n  }\n  destroy() {\n    this.renderer.destroy();\n  }\n}\nfunction VueNodeViewRenderer(component, options) {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new VueNodeView(component, props, options);\n  };\n}\nexport { BubbleMenu, Editor, EditorContent, FloatingMenu, NodeViewContent, NodeViewWrapper, VueNodeViewRenderer, VueRenderer, nodeViewProps, useEditor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}