{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection, NodeSelection } from '@tiptap/pm/state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain,\n        state\n      }) => {\n        const {\n          $to: $originTo\n        } = state.selection;\n        const currentChain = chain();\n        if ($originTo.parentOffset === 0) {\n          currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain\n        // set cursor after horizontal rule\n        .command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}